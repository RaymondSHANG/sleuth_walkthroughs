---
title: "Accounting for batch effects in sleuth"
output:
  html_document:
    toc: true
    theme: default
---
# Introduction

This walkthrough teaches how to test for differential expression in a way that is informed by known batch effects in the data. The example uses data from the paper Bottomly et al., Evaluating Gene Expression in C57BL/6J and DBA/2J Mouse Striatum Using RNA-Seq and Microarrays, _PLoS One_, 2011.


# Preliminaries

Make sure you are in the `R` directory.
This can be done with `setwd()`.

Requirements for this walkthrough:

- `biomaRt`

To install the package:

```{r eval=FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite("biomaRt")
```

- The kallisto results which can be downloaded:

```{bash eval=FALSE}
wget -O ../Bottomly_results.zip https://www.dropbox.com/s/gnbnkuup3pdfenk/Bottomly_results.zip?dl=1
unzip ../Bottomly_results.zip -d ../results
```

- `sleuth`
 
To install sleuth:

```{r}
library('sleuth')
```

## Parsing metadata

A sleuth analysis is dependent on a metadata file, which describes the experimental design, the sample names, conditions and covariates. The metadata file is external to sleuth, and must be prepared prior to analysis. The first step in a sleuth analysis is loading of the metadata file:


```{r}
metadata <- read.csv('../metadata/experiment.csv', stringsAsFactors = FALSE)
```

```{r}
head(metadata,n = 20)
```

This file describes the experimental design. The first column lists the short read archive accession for each sample that is part of the experiment to be analayzed. The biological condition is recorded in the "strain" column. The last two columns describe how the sequencing was undertaken and reveal that certain batches were sequenced together.

```{r}
extract_metadata <- function(library_name) {
  ret <- lapply(strsplit(library_name, '_'),
    function(x) {
      data.frame(strain = x[1], experiment = x[2], lane = x[3],
        stringsAsFactors = FALSE)
    })
  dplyr::bind_rows(ret)
}

metadata <- dplyr::select(metadata, -strain)
metadata <- dplyr::bind_cols(metadata, extract_metadata(metadata$library_name))
metadata <- dplyr::select(metadata, run_accession, library_name, strain,
  experiment, lane)
```

Finally, we add the path names of the kallisto output directories to the metadata table:

```{r}
metadata <- dplyr::mutate(metadata,
  path = file.path('/Users/lpachter/data/sleuth_walkthroughs/Bottomly', 'results', 'single', run_accession, 'kallisto'))
head(metadata)
```
It is important to spot check the metadata file again to make sure that the kallisto runs correspond to the accession numbers in the table, so that each row is associated with the correct sample.

```{r}
metadata <- dplyr::rename(metadata, sample = run_accession)
```

## Associating transcripts to genes

The sample quantifications performed by kallisto have produced transcript abundance and count estimates. These have been parsed by sleuth in the steps just performed, however sleuth does not "know" about genes yet. To perform gene-level analysis sleuth must parse a gene annotation. One easy way to do this is using biomaRt and Ensembl:

```{r}
mart <- biomaRt::useMart(biomart = "ENSEMBL_MART_ENSEMBL",
  dataset = "mmusculus_gene_ensembl",
  host = "dec2015.archive.ensembl.org")
  # host = "ensembl.org")
ttg <- biomaRt::getBM(
  attributes = c("ensembl_transcript_id", "transcript_version",
  "ensembl_gene_id", "external_gene_name", "description",
  "transcript_biotype"),
  mart = mart)
ttg <- dplyr::rename(ttg, target_id = ensembl_transcript_id,
  ens_gene = ensembl_gene_id, ext_gene = external_gene_name)
head(ttg)
```

The resulting table contains Ensembl gene names (column 3) and the associated transcripts (column 1). Note that the gene-transcript mapping must be compatible with the transcriptome used with kallisto. In other words, to use Ensembl transcript-gene associations kallisto was run using the Ensembl transcriptome.

## Preparing the analysis

```{r}
# TODO: temporary -- remove
metadata <- dplyr::filter(metadata, sample != 'SRR099223')
```

```{r}
so <- sleuth_prep(metadata, ~strain, target_mapping = ttg,
  aggregation_column = 'ens_gene', extra_bootstrap_summary = TRUE)
```

## The naïve analysis

As discussed in the Trapnell _et al_. walkthough, to identify genes differential between two conditions two models must be fit by sleuth. The first is known as the reduced model, and in this case we name the "intercept model". It fits a single parameter for each gene thereby enforcing equal abundances between conditions. The second model is known as the full model, and it includes a parameter that is strain dependent. We call it the "strain model". With the likelihood ratio test sleuth identifies genes whose abundances are significantly better explained when strain is taken into account. The mechanics of the fitting are: 

```{r}
so <- sleuth_fit(so, ~1, 'intercept')
so <- sleuth_fit(so, ~strain, 'strain')
```
The likelihood ratio test (lrt) is performed with

```{r}
so <- sleuth_lrt(so, 'intercept', 'strain')
```

Significantly differential genes are extracted with the commands
```{r}
sleuth_table_strain <- sleuth_results(so, 'intercept:strain', 'lrt', show_all = FALSE)
sleuth_significant_strain <- dplyr::filter(sleuth_table_strain, qval <= 0.05)
```

The most significant genes are

```{r}
head(sleuth_significant_strain,20)
```

A (poor) analysis might end here, but a principal component analysis (PCA) of the kallisto abundances shows that while the samples appear to be clustered into a few distinct groups, they are not well-separated by strain.

```{r}
plot_pca(so, color_by = 'strain')
```

The source of the clustering is revealed by coloring the samples by "lane" instead:

```{r}
plot_pca(so, color_by = 'lane')
```

This batch effect is problematic, as genes might be identified as differential in the strain analysis merely because they were sequenced on different lanes. 

## Batch analysis

To test whether this is in fact the case, the test described above can be repeated with the full model comprising a paramter for "lane" instead of "strain".

```{r}
so <- sleuth_fit(so, ~lane, 'lane')
```

The likelihood ratio test is performed as before except with the lane model
```{r}
so <- sleuth_lrt(so, 'intercept', 'lane')
```

The differential analysis test now reveals genes most affected by batch:
```{r}
sleuth_table_lane <- sleuth_results(so, 'intercept:lane', 'lrt', show_all = FALSE)
sleuth_significant_lane <- dplyr::filter(sleuth_table_lane, qval <= 0.05)
head(sleuth_significant_lane,20)
```

To identify genes that are truly differential between strain, it is therefore necessary to fit and account for the (lane) batch effect.

## Fitting a model that acounts for batch

To account for batch while testing for strain differences, the full model must include parameters for both lane and strain.

```{r}
so <- sleuth_fit(so, ~lane + strain, 'full')
```

The reduced model must still include a parameter for the lane. In this way, the strain differences are accounted for while conditioning on the lane. This model, the "lane model" has already been fit. So the likelihood ratio test can now be applied as before:

```{r}
so <- sleuth_lrt(so, 'lane', 'full')
sleuth_table <- sleuth_results(so, 'lane:full', 'lrt', show_all = FALSE)
sleuth_significant <- dplyr::filter(sleuth_table, qval <= 0.05)
head(sleuth_significant,20)
```

While the top 8 genes are the same as in the naïve analysis, differences start to emerge afterwards. Furthermore, the top genes emerge as more significantly differential when conditioning on batch. 


# Comparing to the microarray data

```{r}
illumina <- data.table::fread('../results/journal.pone.0017820.s011.TXT',
  data.table = FALSE)
```

```{r}
affymetrix <- data.table::fread('../results/journal.pone.0017820.s010.TXT',
  data.table = FALSE)
```

## merging all of the results

```{r}
illumina <- dplyr::select(illumina, target_id = Ensembl, illumina_qval = q.value)
affymetrix <- dplyr::select(affymetrix, target_id = Ensembl, affymetrix_qval = q.value)
```

```{r}
all_methods <- Reduce(
  function(x, y) {
    dplyr::inner_join(x, y, by = 'target_id')
  },
  list(
    dplyr::select(sleuth_table, target_id, with_batch_qval = qval),
    dplyr::select(strain_only, target_id, without_batch_qval = qval),
    illumina,
    affymetrix)
)

all_methods <- dplyr::distinct(all_methods)
```
