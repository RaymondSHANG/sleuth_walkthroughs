---
title: "Accounting for batch effects in sleuth"
output:
  html_document:
    toc: true
    theme: default
---
# Introduction

This walkthrough teaches how to test for differential expression in a way that is informed by known batch effects in the data. The example uses data from the paper Bottomly et al., Evaluating Gene Expression in C57BL/6J and DBA/2J Mouse Striatum Using RNA-Seq and Microarrays, _PLoS One_, 2011.


# Preliminaries

Requirements for this walkthrough:

- `biomaRt`

To install the package enter:

```
source("https://bioconductor.org/biocLite.R")
biocLite("biomaRt")
```

Load sleuth:

```{r}
library('sleuth')
```

## Parsing metadata

A sleuth analysis is dependent on a metadata file, which describes the experimental design, the sample names, conditions and covariates. The metadata file is external to sleuth, and must be prepared prior to analysis. The first step in a sleuth analysis is loading of the metadata file:


```{r}
metadata <- read.csv('../metadata/experiment.csv', stringsAsFactors = FALSE)
```

```{r}
head(metadata,n = 20)
```

This file describes the experimental design. The first column lists the short read archive accession for each sample that is part of the experiment to be analayzed. The biological condition is recorded in the "strain" column. The last two columns describe how the sequencing was undertaken and reveal that certain batches were sequenced together.

```{r}
extract_metadata <- function(library_name) {
  ret <- lapply(strsplit(library_name, '_'),
    function(x) {
      data.frame(strain = x[1], experiment = x[2], lane = x[3],
        stringsAsFactors = FALSE)
    })
  dplyr::bind_rows(ret)
}

metadata <- dplyr::select(metadata, -strain)
metadata <- dplyr::bind_cols(metadata, extract_metadata(metadata$library_name))
metadata <- dplyr::select(metadata, run_accession, library_name, strain,
  experiment, lane)
```

Finally, we add the path names of the kallisto output directories to the metadata table:

```{r}
metadata <- dplyr::mutate(metadata,
  path = file.path('..', 'results', 'single', run_accession, 'kallisto'))
head(metadata)
```
It is important to spot check the metadata file again to make sure that the kallisto runs correspond to the accession numbers in the table, so that each row is associated with the correct sample.

```{r}
metadata <- dplyr::rename(metadata, sample = run_accession)
```

## Associating transcripts to genes

The sample quantifications performed by kallisto have produced transcript abundance and count estimates. These have been parsed by sleuth in the steps just performed, however sleuth does not "know" about genes yet. To perform gene-level analysis sleuth must parse a gene annotation. One easy way to do this is using biomaRt and Ensembl:

```{r}
mart <- biomaRt::useMart(biomart = "ENSEMBL_MART_ENSEMBL",
  dataset = "mmusculus_gene_ensembl",
  host = "dec2015.archive.ensembl.org")
  # host = "ensembl.org")
ttg <- biomaRt::getBM(
  attributes = c("ensembl_transcript_id", "transcript_version",
  "ensembl_gene_id", "external_gene_name", "description",
  "transcript_biotype"),
  mart = mart)
ttg <- dplyr::rename(ttg,
  ens_gene = ensembl_gene_id, ext_gene = external_gene_name)
ttg <- dplyr::mutate(ttg, target_id = paste(ensembl_transcript_id,
  transcript_version, sep = "."))
head(ttg)
```

The resulting table contains Ensembl gene names (column 3) and the associated transcripts (column 1). Note that the gene-transcript mapping must be compatible with the transcriptome used with kallisto. In other words, to use Ensembl transcript-gene associations kallisto was run using the Ensembl transcriptome.

## Preparing the analysis

```{r}
so <- sleuth_prep(metadata, ~strain, target_mapping = ttg,
  aggregation_column = 'ens_gene', extra_bootstrap_summary = TRUE)
```

## Examining the batch effects

```{r}
plot_pca(so, color_by = 'strain')
```

```{r}
plot_pca(so, color_by = 'lane')
```

## fitting the full model


```{r}
so <- sleuth_fit(so, ~lane + strain)
```

## fitting the reduced model

```{r}
so <- sleuth_fit(so, ~lane, 'reduced')
```

## computing the test

```{r}
so <- sleuth_lrt(so, 'reduced', 'full')
```

```{r}
sleuth_table <- sleuth_results(so, 'reduced:full', 'lrt', show_all = FALSE)
sleuth_significant <- dplyr::filter(sleuth_table, qval <= 0.05)
```

## ignoring batch

```{r}
so <- sleuth_fit(so, ~strain, 'strain')
so <- sleuth_fit(so, ~1, 'intercept')
so <- sleuth_lrt(so, 'intercept', 'strain')
```

```{r}
strain_only <- sleuth_results(so, 'intercept:strain', 'lrt', show_all = FALSE)
strain_only <- distinct(dplyr::select(strain_only, target_id, qval))
strain_only_significant <- dplyr::filter(strain_only, qval <= 0.05)
```



# Comparing to the microarray data

```{r}
illumina <- data.table::fread('../results/journal.pone.0017820.s011.TXT',
  data.table = FALSE)
```

```{r}
affymetrix <- data.table::fread('../results/journal.pone.0017820.s010.TXT',
  data.table = FALSE)
```

## merging all of the results

```{r}
illumina <- dplyr::select(illumina, target_id = Ensembl, illumina_qval = q.value)
affymetrix <- dplyr::select(affymetrix, target_id = Ensembl, affymetrix_qval = q.value)
```

```{r}
all_methods <- Reduce(
  function(x, y) {
    dplyr::inner_join(x, y, by = 'target_id')
  },
  list(
    dplyr::select(sleuth_table, target_id, with_batch_qval = qval),
    dplyr::select(strain_only, target_id, without_batch_qval = qval),
    illumina,
    affymetrix)
)

all_methods <- dplyr::distinct(all_methods)
```
